{
  "schema_version": "1.0.0",
  "link_map_id": "lean.invariant_theorem_test_link_map.v1",
  "generated_by": "asupersync-24rak",
  "generated_at": "2026-02-16T20:10:00Z",
  "source_artifacts": {
    "invariant_status_inventory": "formal/lean/coverage/invariant_status_inventory.json",
    "theorem_surface_inventory": "formal/lean/coverage/theorem_surface_inventory.json",
    "theorem_rule_traceability_ledger": "formal/lean/coverage/theorem_rule_traceability_ledger.json"
  },
  "linkage_policy": {
    "theorem_witnesses_must_exist_in_theorem_inventory": true,
    "rule_links_resolve_via_theorem_rule_traceability_ledger": true,
    "test_paths_must_exist": true,
    "gap_rows_require_owner_and_dependency_blockers": true,
    "enforce_via_test": "tests/lean_invariant_theorem_test_link_map.rs"
  },
  "reliability_hardening_contract": {
    "contract_id": "lean.track6.reliability_hardening.v1",
    "source_bead": "asupersync-2izu4",
    "classification_policy": {
      "required_assumption_classes": [
        "budget_constraints",
        "cancellation_protocol",
        "region_lifecycle",
        "obligation_resolution"
      ],
      "incident_severity_levels": [
        "sev1",
        "sev2",
        "sev3"
      ]
    },
    "assumption_class_matrix": [
      {
        "assumption_class": "budget_constraints",
        "invariant_ids": [
          "inv.cancel.protocol",
          "inv.region_close.quiescence"
        ],
        "checklist_ids": [
          "budget_monotonicity",
          "evidence_commands"
        ],
        "conformance_artifacts": [
          "formal/lean/coverage/refinement_conformance_report_v1.json",
          "tests/refinement_conformance.rs"
        ],
        "governance_cadence_ids": [
          "weekly",
          "phase-exit"
        ],
        "failure_policy": "fail-safe",
        "policy_rationale": "Budget drift can be tolerated briefly only when cleanup budgets remain bounded and recovery evidence is retained."
      },
      {
        "assumption_class": "cancellation_protocol",
        "invariant_ids": [
          "inv.cancel.protocol",
          "inv.race.losers_drained"
        ],
        "checklist_ids": [
          "cancel_protocol_order",
          "race_loser_drain",
          "evidence_commands"
        ],
        "conformance_artifacts": [
          "tests/cancellation_conformance.rs",
          "tests/refinement_conformance.rs"
        ],
        "governance_cadence_ids": [
          "weekly",
          "phase-exit"
        ],
        "failure_policy": "fail-fast",
        "policy_rationale": "Cancellation-order regressions can strand work and obligations, so merges must stop until protocol ordering is restored."
      },
      {
        "assumption_class": "region_lifecycle",
        "invariant_ids": [
          "inv.region_close.quiescence",
          "inv.structured_concurrency.single_owner"
        ],
        "checklist_ids": [
          "region_quiescence",
          "determinism_surface",
          "evidence_commands"
        ],
        "conformance_artifacts": [
          "tests/region_lifecycle_conformance.rs",
          "tests/refinement_conformance.rs"
        ],
        "governance_cadence_ids": [
          "weekly",
          "phase-exit"
        ],
        "failure_policy": "fail-safe",
        "policy_rationale": "Operational mitigations may be applied while restoring lifecycle invariants, but unresolved leaks/quiescence gaps stay escalated."
      },
      {
        "assumption_class": "obligation_resolution",
        "invariant_ids": [
          "inv.obligation.no_leaks",
          "inv.region_close.quiescence"
        ],
        "checklist_ids": [
          "obligation_totality",
          "evidence_commands"
        ],
        "conformance_artifacts": [
          "tests/cancel_obligation_invariants.rs",
          "tests/obligation_lifecycle_e2e.rs"
        ],
        "governance_cadence_ids": [
          "weekly",
          "phase-exit"
        ],
        "failure_policy": "fail-fast",
        "policy_rationale": "Unresolved obligations violate safety invariants directly and must block promotion until commit/abort/leak coverage is restored."
      }
    ],
    "incident_triage_flow": [
      {
        "step_id": "classify_assumption",
        "description": "Map incident symptom to exactly one assumption class before proposing remediation.",
        "required_outputs": [
          "assumption_class",
          "candidate_invariant_ids",
          "severity"
        ]
      },
      {
        "step_id": "verify_guardrails",
        "description": "Run checklist and conformance evidence linked to the chosen assumption class.",
        "required_outputs": [
          "failed_checklist_items",
          "conformance_artifacts",
          "evidence_command_log"
        ]
      },
      {
        "step_id": "route_disposition",
        "description": "Select fail-fast or fail-safe disposition using policy rationale and observed severity.",
        "required_outputs": [
          "failure_policy",
          "mitigation_owner",
          "next_review_cadence"
        ]
      },
      {
        "step_id": "governance_escalation",
        "description": "Escalate unresolved guardrail failures into governance threads and blocker beads.",
        "required_outputs": [
          "blocker_bead_id",
          "governance_thread",
          "signoff_status"
        ]
      }
    ]
  },
  "invariant_links": [
    {
      "invariant_id": "inv.authority.no_ambient",
      "invariant_name": "No ambient authority",
      "proof_status": "unproven",
      "theorem_witnesses": [],
      "executable_checks": [
        "tests/property_cap_obligation.rs",
        "tests/cap_obligation_compile_fail.rs",
        "tests/integration_e2e.rs"
      ],
      "assumption_envelope": {
        "assumption_id": "safety.authority.no_ambient.v1",
        "assumptions": [
          "Capability-bearing APIs remain the sole gateway for side effects in runtime and combinator surfaces.",
          "Compile-fail and property suites capture ambient-authority regressions that are not yet Lean-proven.",
          "No ambient effect path bypasses Cx capability flow without failing conformance checks."
        ],
        "runtime_guardrails": [
          "New effectful APIs must thread explicit capabilities instead of introducing ambient global state.",
          "Capability compile-fail suites must stay in deterministic CI for every coverage artifact refresh.",
          "Authority-sensitive paths must keep explicit audit traces for regression triage."
        ]
      },
      "composition_contract": {
        "status": "planned",
        "consumed_by": [
          "tests/property_cap_obligation.rs",
          "tests/cap_obligation_compile_fail.rs",
          "tests/integration_e2e.rs"
        ],
        "feeds_invariants": [
          "inv.structured_concurrency.single_owner",
          "inv.obligation.no_leaks"
        ]
      },
      "explicit_gaps": [
        {
          "gap_id": "inv.authority.no_ambient.gap.lean-proof-family-missing",
          "description": "Capability discipline is heavily tested in Rust, but no dedicated Lean proof family exists yet for ambient-authority exclusion.",
          "owner": "MagentaBridge",
          "dependency_blockers": [
            "bd-2iwok",
            "bd-1vhw5"
          ]
        }
      ]
    },
    {
      "invariant_id": "inv.cancel.protocol",
      "invariant_name": "Cancellation is a protocol: request -> drain -> finalize (idempotent)",
      "proof_status": "partially_proven",
      "theorem_witnesses": [
        {
          "theorem": "cancel_masked_step",
          "theorem_line": 1666,
          "rule_ids": [
            "step.cancelMasked"
          ]
        },
        {
          "theorem": "cancel_ack_step",
          "theorem_line": 1686,
          "rule_ids": [
            "step.cancelAcknowledge"
          ]
        },
        {
          "theorem": "cancel_finalize_step",
          "theorem_line": 1700,
          "rule_ids": [
            "step.cancelFinalize"
          ]
        },
        {
          "theorem": "cancel_complete_step",
          "theorem_line": 1713,
          "rule_ids": [
            "step.cancelComplete"
          ]
        },
        {
          "theorem": "cancel_complete_produces_cancelled",
          "theorem_line": 1733,
          "rule_ids": [
            "step.cancelComplete"
          ]
        },
        {
          "theorem": "cancelMasked_potential_decreases",
          "theorem_line": 3171,
          "rule_ids": [
            "step.cancelMasked"
          ]
        },
        {
          "theorem": "cancelAcknowledge_potential_decreases",
          "theorem_line": 3186,
          "rule_ids": [
            "step.cancelAcknowledge"
          ]
        },
        {
          "theorem": "cancelFinalize_potential_decreases",
          "theorem_line": 3200,
          "rule_ids": [
            "step.cancelFinalize"
          ]
        },
        {
          "theorem": "cancelComplete_potential_reaches_zero",
          "theorem_line": 3213,
          "rule_ids": [
            "step.cancelComplete"
          ]
        },
        {
          "theorem": "cancel_protocol_terminates",
          "theorem_line": 3254,
          "rule_ids": [
            "step.cancelComplete"
          ]
        },
        {
          "theorem": "cancel_steps_testable_bound",
          "theorem_line": 3309,
          "rule_ids": [
            "step.cancelComplete"
          ]
        },
        {
          "theorem": "cancel_propagation_bounded",
          "theorem_line": 3333,
          "rule_ids": [
            "step.cancelChild",
            "step.cancelPropagate"
          ]
        }
      ],
      "executable_checks": [
        "tests/cancellation_conformance.rs",
        "tests/cancellation_stress_e2e.rs",
        "tests/cancel_obligation_invariants.rs",
        "tests/refinement_conformance.rs"
      ],
      "assumption_envelope": {
        "assumption_id": "liveness.cancel.protocol.v1",
        "assumptions": [
          "Cancellation potential decreases monotonically across cancel ladder steps.",
          "Task cancellation reaches Cancelled via bounded finalize/complete progression.",
          "Child cancellation propagation is bounded and eventually observed."
        ],
        "runtime_guardrails": [
          "Cancellation paths must preserve bounded cleanup budgets.",
          "Cancel protocol transitions must remain request -> drain -> finalize -> complete.",
          "Scheduler fairness assumptions for non-cancel progress are enforced by conformance checks."
        ]
      },
      "composition_contract": {
        "status": "ready",
        "consumed_by": [
          "tests/refinement_conformance.rs",
          "tests/cancellation_conformance.rs"
        ],
        "feeds_invariants": [
          "inv.race.losers_drained",
          "inv.obligation.no_leaks"
        ]
      },
      "explicit_gaps": [
        {
          "gap_id": "inv.cancel.protocol.gap.idempotence-theorem-missing",
          "description": "Idempotence of repeated cancel requests is not captured as a dedicated Lean theorem.",
          "owner": "GentleHeron",
          "dependency_blockers": [
            "bd-1ab3k"
          ]
        }
      ]
    },
    {
      "invariant_id": "inv.obligation.no_leaks",
      "invariant_name": "No obligation leaks",
      "proof_status": "partially_proven",
      "theorem_witnesses": [
        {
          "theorem": "commit_resolves",
          "theorem_line": 675,
          "rule_ids": [
            "step.commit"
          ]
        },
        {
          "theorem": "abort_resolves",
          "theorem_line": 691,
          "rule_ids": [
            "step.abort"
          ]
        },
        {
          "theorem": "leak_marks_leaked",
          "theorem_line": 707,
          "rule_ids": [
            "step.leak"
          ]
        },
        {
          "theorem": "commit_removes_from_ledger",
          "theorem_line": 723,
          "rule_ids": [
            "step.commit"
          ]
        },
        {
          "theorem": "abort_removes_from_ledger",
          "theorem_line": 747,
          "rule_ids": [
            "step.abort"
          ]
        },
        {
          "theorem": "leak_removes_from_ledger",
          "theorem_line": 770,
          "rule_ids": [
            "step.leak"
          ]
        },
        {
          "theorem": "committed_obligation_stable",
          "theorem_line": 2488,
          "rule_ids": [
            "step.commit"
          ]
        },
        {
          "theorem": "aborted_obligation_stable",
          "theorem_line": 2898,
          "rule_ids": [
            "step.abort"
          ]
        },
        {
          "theorem": "leaked_obligation_stable",
          "theorem_line": 2996,
          "rule_ids": [
            "step.leak"
          ]
        },
        {
          "theorem": "obligation_in_ledger_blocks_close",
          "theorem_line": 939,
          "rule_ids": []
        },
        {
          "theorem": "close_implies_ledger_empty",
          "theorem_line": 808,
          "rule_ids": [
            "step.close"
          ]
        },
        {
          "theorem": "call_obligation_resolved_at_close",
          "theorem_line": 3679,
          "rule_ids": []
        },
        {
          "theorem": "no_reserved_call_obligations_after_close",
          "theorem_line": 3689,
          "rule_ids": []
        },
        {
          "theorem": "registry_lease_resolved_at_close",
          "theorem_line": 3724,
          "rule_ids": []
        }
      ],
      "executable_checks": [
        "tests/obligation_lifecycle_e2e.rs",
        "tests/cancel_obligation_invariants.rs",
        "tests/leak_regression_e2e.rs",
        "tests/lease_semantics.rs"
      ],
      "assumption_envelope": {
        "assumption_id": "safety.obligation.no_leaks.v1",
        "assumptions": [
          "Every reserve pathway eventually resolves via commit/abort/leak transitions recorded in the ledger model.",
          "Close/quiescence checks continue to treat unresolved obligations as blockers to completion.",
          "Existing theorem witnesses over commit/abort/leak stability compose with runtime conformance traces."
        ],
        "runtime_guardrails": [
          "Obligation lifecycle tests must remain deterministic and replayable across artifact refreshes.",
          "Ledger transition code paths must preserve explicit terminal-state transitions without silent drops.",
          "Leak-related regressions must block merge via obligation conformance gates."
        ]
      },
      "composition_contract": {
        "status": "partial",
        "consumed_by": [
          "tests/obligation_lifecycle_e2e.rs",
          "tests/cancel_obligation_invariants.rs",
          "tests/leak_regression_e2e.rs",
          "tests/lease_semantics.rs"
        ],
        "feeds_invariants": [
          "inv.region_close.quiescence",
          "inv.race.losers_drained"
        ]
      },
      "explicit_gaps": [
        {
          "gap_id": "inv.obligation.no_leaks.gap.global-zero-leak-theorem-missing",
          "description": "A single global theorem stating zero leaked obligations across all reachable executions is not yet present.",
          "owner": "MagentaBridge",
          "dependency_blockers": [
            "bd-3k6l5",
            "asupersync-1pdet"
          ]
        }
      ]
    },
    {
      "invariant_id": "inv.race.losers_drained",
      "invariant_name": "Losers are drained after races",
      "proof_status": "unproven",
      "theorem_witnesses": [
        {
          "theorem": "cancel_propagation_bounded",
          "theorem_line": 3333,
          "rule_ids": [
            "step.cancelChild",
            "step.cancelPropagate"
          ]
        },
        {
          "theorem": "step_preserves_wellformed",
          "theorem_line": 3070,
          "rule_ids": [
            "step.cancelChild",
            "step.enqueue",
            "step.schedule",
            "step.scheduleStep"
          ]
        }
      ],
      "executable_checks": [
        "tests/e2e/combinator/cancel_correctness/loser_drain.rs",
        "tests/e2e/combinator/cancel_correctness/async_loser_drain.rs",
        "tests/cancel_obligation_invariants.rs",
        "tests/runtime_e2e.rs"
      ],
      "assumption_envelope": {
        "assumption_id": "liveness.race.losers_drained.v1",
        "assumptions": [
          "Race losers are cancelled through bounded propagation and cannot continue user-visible effects.",
          "Loser tasks remain structurally wellformed while draining to terminal states.",
          "Drain completion is observable in deterministic E2E loser-drain harnesses."
        ],
        "runtime_guardrails": [
          "Combinator race implementations must cancel all non-winning branches.",
          "Loser-drain pathways must be instrumented for deterministic replay and diagnosis.",
          "Loser-drain regressions must fail conformance before merge."
        ]
      },
      "composition_contract": {
        "status": "partial",
        "consumed_by": [
          "tests/runtime_e2e.rs",
          "tests/refinement_conformance.rs",
          "tests/e2e/combinator/cancel_correctness/loser_drain.rs"
        ],
        "feeds_invariants": [
          "inv.cancel.protocol",
          "inv.obligation.no_leaks"
        ]
      },
      "explicit_gaps": [
        {
          "gap_id": "inv.race.losers_drained.gap.direct-lean-theorem-missing",
          "description": "No direct Lean theorem currently states and proves race-loser full-drain semantics.",
          "owner": "GentleHeron",
          "dependency_blockers": [
            "bd-19efq",
            "bd-244p5"
          ]
        }
      ]
    },
    {
      "invariant_id": "inv.region_close.quiescence",
      "invariant_name": "Region close = quiescence",
      "proof_status": "fully_proven",
      "theorem_witnesses": [
        {
          "theorem": "close_implies_quiescent",
          "theorem_line": 794,
          "rule_ids": [
            "step.close"
          ]
        },
        {
          "theorem": "close_implies_ledger_empty",
          "theorem_line": 808,
          "rule_ids": [
            "step.close"
          ]
        },
        {
          "theorem": "close_implies_finalizers_empty",
          "theorem_line": 820,
          "rule_ids": [
            "step.close"
          ]
        },
        {
          "theorem": "quiescent_tasks_completed",
          "theorem_line": 860,
          "rule_ids": []
        },
        {
          "theorem": "quiescent_subregions_closed",
          "theorem_line": 867,
          "rule_ids": []
        },
        {
          "theorem": "quiescent_no_obligations",
          "theorem_line": 874,
          "rule_ids": []
        },
        {
          "theorem": "quiescent_no_finalizers",
          "theorem_line": 881,
          "rule_ids": []
        },
        {
          "theorem": "close_quiescence_decomposition",
          "theorem_line": 889,
          "rule_ids": [
            "step.close"
          ]
        },
        {
          "theorem": "close_complete_step",
          "theorem_line": 1806,
          "rule_ids": [
            "step.close"
          ]
        }
      ],
      "executable_checks": [
        "tests/close_quiescence_regression.rs",
        "tests/region_lifecycle_conformance.rs",
        "tests/refinement_conformance.rs"
      ],
      "assumption_envelope": {
        "assumption_id": "liveness.region_close.quiescence.v1",
        "assumptions": [
          "Region close executes close ladder transitions to Closed under bounded finalizer progress.",
          "Quiescence decomposition remains equivalent to no-live-tasks/no-live-subregions/no-obligations/no-finalizers.",
          "Close completion implies quiescent observable state for dependent conformance harnesses."
        ],
        "runtime_guardrails": [
          "Region close transitions must preserve close-state monotonicity.",
          "Finalizer execution and child cancellation must remain bounded by configured cleanup budgets.",
          "Close/quiescence conformance checks must remain part of deterministic CI suites."
        ]
      },
      "composition_contract": {
        "status": "ready",
        "consumed_by": [
          "tests/refinement_conformance.rs",
          "tests/region_lifecycle_conformance.rs"
        ],
        "feeds_invariants": [
          "inv.structured_concurrency.single_owner",
          "inv.obligation.no_leaks"
        ]
      },
      "explicit_gaps": []
    },
    {
      "invariant_id": "inv.structured_concurrency.single_owner",
      "invariant_name": "Structured concurrency: every task is owned by exactly one region",
      "proof_status": "partially_proven",
      "theorem_witnesses": [
        {
          "theorem": "spawn_preserves_existing_task",
          "theorem_line": 999,
          "rule_ids": [
            "step.spawn"
          ]
        },
        {
          "theorem": "spawn_preserves_obligation",
          "theorem_line": 1265,
          "rule_ids": [
            "step.spawn"
          ]
        },
        {
          "theorem": "spawn_preserves_wellformed",
          "theorem_line": 1844,
          "rule_ids": [
            "step.spawn"
          ]
        },
        {
          "theorem": "spawned_task_in_region",
          "theorem_line": 2706,
          "rule_ids": [
            "step.spawn"
          ]
        },
        {
          "theorem": "setTask_same_region_preserves_wellformed",
          "theorem_line": 2752,
          "rule_ids": []
        },
        {
          "theorem": "setRegion_structural_preserves_wellformed",
          "theorem_line": 2797,
          "rule_ids": []
        },
        {
          "theorem": "step_preserves_wellformed",
          "theorem_line": 3070,
          "rule_ids": [
            "step.cancelChild",
            "step.enqueue",
            "step.schedule",
            "step.scheduleStep"
          ]
        }
      ],
      "executable_checks": [
        "tests/property_region_ops.rs",
        "tests/region_lifecycle_conformance.rs",
        "tests/integration_e2e.rs"
      ],
      "assumption_envelope": {
        "assumption_id": "safety.structured_concurrency.single_owner.v1",
        "assumptions": [
          "Spawn and schedule transitions preserve single-owner task membership in the modeled region tree.",
          "Wellformedness invariants continue to imply non-duplicated ownership across task IDs.",
          "Executable region ownership tests provide deterministic regression evidence where Lean remains partial."
        ],
        "runtime_guardrails": [
          "Task migration and scheduling paths must preserve owner region IDs without aliasing.",
          "Region lifecycle tests must continue to assert ownership/quiescence coupling in CI.",
          "Any ownership model change requires traceability updates in theorem/test linkage artifacts."
        ]
      },
      "composition_contract": {
        "status": "partial",
        "consumed_by": [
          "tests/property_region_ops.rs",
          "tests/region_lifecycle_conformance.rs",
          "tests/integration_e2e.rs"
        ],
        "feeds_invariants": [
          "inv.region_close.quiescence",
          "inv.cancel.protocol"
        ]
      },
      "explicit_gaps": [
        {
          "gap_id": "inv.structured_concurrency.single_owner.gap.global-uniqueness-theorem-missing",
          "description": "No single explicit theorem stating global uniqueness of region ownership for all task IDs.",
          "owner": "MagentaBridge",
          "dependency_blockers": [
            "bd-nc3ut",
            "bd-2iwok"
          ]
        }
      ]
    }
  ],
  "cross_entity_liveness_composition": {
    "contract_id": "lean.track3.cross_entity_liveness.v1",
    "source_bead": "asupersync-24rak",
    "assumption_catalog": [
      {
        "assumption_id": "assume.cancel.checkpoint_observability.v1",
        "statement": "Runtime tasks observe cancellation through explicit checkpoints so cancellation progression can be witnessed and bounded in traces.",
        "evidence_refs": [
          "src/cx/cx.rs:1090",
          "src/cancel/symbol_cancel.rs"
        ]
      },
      {
        "assumption_id": "assume.cancel.streak_fairness_bound.v1",
        "statement": "Scheduler cancel-lane streak limits preserve eventual timed/ready dispatch opportunities under sustained cancellation pressure.",
        "evidence_refs": [
          "src/runtime/scheduler/three_lane.rs:14",
          "src/runtime/scheduler/three_lane.rs:1206"
        ]
      },
      {
        "assumption_id": "assume.race.loser_drain_waits.v1",
        "statement": "Race combinators do not return until non-winning branches are cancelled and drained under structured scope ownership.",
        "evidence_refs": [
          "src/cx/scope.rs:884",
          "tests/e2e/combinator/cancel_correctness/loser_drain.rs"
        ]
      },
      {
        "assumption_id": "assume.close.quiescence_guard.v1",
        "statement": "Region close transitions require quiescence preconditions (no live descendants and no unresolved obligations) before terminal close completion.",
        "evidence_refs": [
          "src/runtime/state.rs",
          "formal/lean/Asupersync.lean:794"
        ]
      }
    ],
    "invariant_ids": [
      "inv.cancel.protocol",
      "inv.race.losers_drained",
      "inv.region_close.quiescence"
    ],
    "theorem_chain": [
      {
        "segment_id": "cancel_ladder",
        "theorems": [
          "cancel_protocol_terminates",
          "cancel_steps_testable_bound",
          "cancel_propagation_bounded"
        ],
        "theorem_sources": [
          {
            "theorem": "cancel_protocol_terminates",
            "file": "formal/lean/Asupersync.lean",
            "line": 3254
          },
          {
            "theorem": "cancel_steps_testable_bound",
            "file": "formal/lean/Asupersync.lean",
            "line": 3309
          },
          {
            "theorem": "cancel_propagation_bounded",
            "file": "formal/lean/Asupersync.lean",
            "line": 3333
          }
        ],
        "assumption_ids": [
          "assume.cancel.checkpoint_observability.v1",
          "assume.cancel.streak_fairness_bound.v1"
        ],
        "guarantee": "Cancellation reaches bounded terminal progression before downstream close sequencing."
      },
      {
        "segment_id": "race_loser_drain",
        "theorems": [
          "cancel_propagation_bounded",
          "step_preserves_wellformed"
        ],
        "theorem_sources": [
          {
            "theorem": "cancel_propagation_bounded",
            "file": "formal/lean/Asupersync.lean",
            "line": 3333
          },
          {
            "theorem": "step_preserves_wellformed",
            "file": "formal/lean/Asupersync.lean",
            "line": 3070
          }
        ],
        "assumption_ids": [
          "assume.cancel.checkpoint_observability.v1",
          "assume.race.loser_drain_waits.v1"
        ],
        "guarantee": "Race losers are cancellation-bounded and structurally wellformed while draining."
      },
      {
        "segment_id": "close_quiescence",
        "theorems": [
          "close_implies_quiescent",
          "close_quiescence_decomposition",
          "close_complete_step"
        ],
        "theorem_sources": [
          {
            "theorem": "close_implies_quiescent",
            "file": "formal/lean/Asupersync.lean",
            "line": 794
          },
          {
            "theorem": "close_quiescence_decomposition",
            "file": "formal/lean/Asupersync.lean",
            "line": 889
          },
          {
            "theorem": "close_complete_step",
            "file": "formal/lean/Asupersync.lean",
            "line": 1806
          }
        ],
        "assumption_ids": [
          "assume.close.quiescence_guard.v1"
        ],
        "guarantee": "Region close concludes only in quiescent state with completed close transition."
      }
    ],
    "end_to_end_guarantees": [
      {
        "guarantee_id": "e2e.cancel_to_quiescence",
        "statement": "Cancel protocol progression composes with close/quiescence proofs so cancellation-triggered shutdown returns only after quiescence.",
        "depends_on_theorems": [
          "cancel_protocol_terminates",
          "cancel_steps_testable_bound",
          "close_quiescence_decomposition",
          "close_complete_step"
        ],
        "assumption_ids": [
          "assume.cancel.checkpoint_observability.v1",
          "assume.cancel.streak_fairness_bound.v1",
          "assume.close.quiescence_guard.v1"
        ],
        "harness_ids": [
          "harness.cancellation_obligation"
        ],
        "consumed_by": [
          "tests/cancellation_conformance.rs",
          "tests/refinement_conformance.rs",
          "tests/region_lifecycle_conformance.rs"
        ]
      },
      {
        "guarantee_id": "e2e.race_loser_drain_to_quiescence",
        "statement": "Race loser-drain sequencing composes with close/quiescence checks so raced scopes return only after loser cancellation is drained and quiescence is re-established.",
        "depends_on_theorems": [
          "cancel_propagation_bounded",
          "step_preserves_wellformed",
          "close_quiescence_decomposition"
        ],
        "assumption_ids": [
          "assume.cancel.checkpoint_observability.v1",
          "assume.race.loser_drain_waits.v1",
          "assume.close.quiescence_guard.v1"
        ],
        "harness_ids": [
          "harness.race_loser_drain"
        ],
        "consumed_by": [
          "tests/e2e/combinator/cancel_correctness/loser_drain.rs",
          "tests/refinement_conformance.rs",
          "tests/runtime_e2e.rs"
        ]
      }
    ],
    "conformance_harness_links": [
      {
        "harness_id": "harness.cancellation_obligation",
        "required_artifacts": [
          "normalized_trace_artifact",
          "mismatch_payload_artifact",
          "repro_manifest_artifact"
        ]
      },
      {
        "harness_id": "harness.race_loser_drain",
        "required_artifacts": [
          "normalized_trace_artifact",
          "mismatch_payload_artifact",
          "repro_manifest_artifact"
        ]
      }
    ]
  },
  "summary": {
    "invariants_total": 6,
    "invariants_with_theorem_witnesses": 5,
    "invariants_with_executable_checks": 6,
    "invariants_with_explicit_gaps": 5,
    "invariants_meeting_theorem_and_check_requirement": 5,
    "invariants_covered_via_explicit_gap_only": 1,
    "gap_entries_total": 5
  }
}
